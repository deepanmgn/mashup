\chapter{Results and Discussion}

This chapter gives an overview of the results obtained and whether these were achieved within the scope of our project and how satisfactory these results are with respect to the objectives and aims of the project. Then, we discuss the importance of these results; explore the limitations faced during the development and the difficulties encountered.

\section{Results}

Upon conceiving the objectives of this project, it is safe to iterate that these objectives were achieved. Our project involved designing a semantic mashup which can gather required data from several source websites and mash the results obtained into our site. The obtained results were also categorized via semantic tags, which were the basic parameters defining any restaurant. As mentioned in the previous chapter, the mashup was also tested with various cuisines and locations, and the results were satisfactory in terms of providing detailed information of restaurants based on our own categorizations.

The results were obtained as we have ascertained based on the working of the mashup. They were some loading time issues which were mainly due to the Google map locations being displayed for each restaurant result. Apart from this, the mashup worked fine with a wide variety of cuisine name queries. Since the user will be aware of what search results will be obtained for cuisine search, testing it with some random terms apart from cuisine names gave us a typical error message pertaining to an attribute error. While developing the mashup, we didn’t take into account the usage of search terms apart from cuisine and location names. For such erroneous queries, we can provide an exception result, such as a customized error message, which can be produced upon searching a non-existent name. The message generated can ask the user to search for a cuisine or location name, since the mashup is mainly programmed for that purpose and can take the user back to the home page.

In terms of the user experience, the results produced can be quite useful for a user in search of a restaurant. Semantic mashups differ from other mashups in terms of providing metadata to the data to make sense of that information. Using the restaurant websites directly, it may be difficult to look for the required information for a restaurant. By placing custom designed columns, each restaurant’s data gathered was filtered only to provide the relevant ones. In our case, we took some attributes like its address, opening times and prices. These attributes are crucial for a user to make a decision so as to visit the restaurant or not. In this way, this semantic mashup does provide a service of recommending restaurants to users based on this collated data. Moreover, the interface is simple but self-explanatory, because all users are used to querying in a search engine, and the program doesn't require more input than that.

\section{Limitations and difficulties}
In terms of limitations, we considered potentially using some of the APIs for restaurant websites. But API reliability was a common problem for some sites and when it’s not up to date, it would cause problems in gathering the required data. Some of the APIs would not be documented properly and most of them would require the mashup developer to have knowledge at an advanced level.

Initially, our plan in the thesis was to have total control of the semantic mashup by programming it completely and scraping off the relevant data automatically. It was never the project’s intended goal to use an API to gather the data, but nevertheless, it was researched upon. However, we were able to gather ratings of the restaurants from a different source by utilizing the website’s API. The results were quite satisfactory. As specified in chapter 2, we also researched many of the software tools that can help to  create mashups without the need of any programming. They weren’t used in the project, since the functionality is pretty limited and couldn’t help in accomplishing our project goals, which have more emphasis in data scraping.

Some of the difficulties encountered were mainly programming issues and choosing the programming language itself. Python was chosen since it was simple and flexible. Python also had useful libraries that make it suitable for web programming. We did encounter difficulties due to some data formats that were unstructured.
